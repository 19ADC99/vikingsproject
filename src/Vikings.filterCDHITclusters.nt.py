#!/usr/bin/env python3.6

'''
I take a cluster file generated by running CDHIT clustering with 70% on amino acid yeast proteins.
I return more refined clusters which should contain only one ortholog.

Andrea Del Cortona
2021/01/11
'''



#------------------------------------------------------------------#
# LOAD LIBRARIES

import argparse
import functools
import os
import re
import shutil
import string
import sys
import itertools
import operator
from datetime import datetime



#------------------------------------------------------------------#
# INPUT PARSER

parser = argparse.ArgumentParser(formatter_class = argparse.RawTextHelpFormatter,
	description = '''
	
	==================================================================
	I take a cluster file generated by running CDHIT clustering with 70% on amino acid yeast proteins.
	I return more refined clusters which should contain only one ortholog.
	
	__________________________________________________________________
	
	## all_plusKV.aa.0.7.fa.clstr example
	
	>Cluster 14
	0	1341aa, >14R30_14R3000002092-RA|>14R30_14R3000002092-RA... at 98.51%
	1	1115aa, >14R30_14R3000002094-RA|>14R30_14R3000002094-RA... at 98.83%
	2	1029aa, >14R30_14R3000002090-RA|>14R30_14R3000002090-RA... at 98.45%
	3	91aa, >14R30_14R3000002093-RA|>14R30_14R3000002093-RA... at 93.41%
	650	3549aa, >x1076_WL1EUKT932875... *
	651	1548aa, >x1079_WL1EUKT939148... at 100.00%


	__________________________________________________________________
	
	Usage:
	python3.6 Vikings.filterCDHITclusters.py --clstr all_plusKV.nt.098.fa.clstr
	
	==================================================================
	''',
	epilog = '''
	__________________________________________________________________
	         Andrea Del Cortona - andrea.delcortona@gmail.com
			               2021-01-11
	__________________________________________________________________
	''')

parser.add_argument("--clstr", metavar ='CLSTR', action = 'store',
	type = str, dest = 'CLSTR', required = True,
	help = 'The cluster output from CD-HIT.')
	
args = parser.parse_args()



#------------------------------------------------------------------#
# FUNCTIONS                                                      

# main function
def main():
	'''
	I read the clstr.
	I divide into smaller clusters with similar length and %id.
	I discard outliers.
	I print the output clusters.
	'''

	# read input datasets
	raw_clstrDB = read_clstr(args.CLSTR)
	
	# divide each cluster in smaller 1 ortholog cluster
	processed_clstr = process_clstr(raw_clstrDB)
	clean_clstrDB = processed_clstr[0]
	filter_log = processed_clstr[1]
	
	# print output files
	print_Log(filter_log)
	print_clstr(clean_clstrDB)
	print_GeneMatrix(clean_clstrDB)



def read_clstr(input):
	'''
	I read a clstr input file.
	I return a dictionary of clusters.
	'''
	
	# declare output dictionary
	raw_clstrDB = {}

	# import clstr file
	with open(input) as infile:
		for line in infile:
			line = line.rstrip('\n')
			# is it a new cluster?
			if line[0] == ">":
				curr_clstr = line[1:]
				raw_clstrDB[curr_clstr] = [[]]
			else:
				Num, Info = line.split('\t')
				LenRaw, NameRaw, *pidRaw = Info.split(' ')
				# clean name and length
				Len = LenRaw.replace(',', '').replace('aa', '')
				Name = NameRaw.replace('>', '').replace('...', '')
				# is it cluster representative?
				if pidRaw == ["*"]:
					raw_clstrDB[curr_clstr][0] = [Name, Len, "100.00"]
				else:
					pid = pidRaw[1].replace('%', '')
					raw_clstrDB[curr_clstr].append([Name, Len, pid])
	
	# protein names sanity check
	for clstr in raw_clstrDB:
		NamesDB = []
		for entry in raw_clstrDB[clstr]:
			if entry[0] in NamesDB:
				sys.stderr.write( "\n# Error: the sequence {} is present more than once in cluster {} \n".format(entry[0], clstr))
				exit
			else:
				NamesDB.append(entry[0])

	return(raw_clstrDB)


	
def process_clstr(raw_clstrDB):
	'''
	I read the raw clusters and divide them according to sequence length,
	percentage of identity with reference sequence.
	I drop outliers.
	I return a list of clusters, and a log with all the entry, wether discarded or not.
	'''
	
	# declare output dictionary
	clean_clstrDB = []
	filter_log = []
	
	# filter clusters
	for clstr in raw_clstrDB:
		# declare temporary clusters
		i = 0
		tmp_clstr = {}
		# reference sequence
		NameR = raw_clstrDB[clstr][0][0]
		LenR = raw_clstrDB[clstr][0][1]
		pidR = raw_clstrDB[clstr][0][2]
		tmp_clstr[i] = [[NameR, LenR, pidR]]
		# iterate through sequences in cluster
		for k in range(len(raw_clstrDB[clstr]) - 1):
			# current sequence
			Name = raw_clstrDB[clstr][k][0]
			Len = raw_clstrDB[clstr][k][1]
			pid = raw_clstrDB[clstr][k][2]
			# retain sequences within 5% of pid and 5% length
			if float(pid) > float(95) and (float(Len) > float(LenR)*0.95 and float(Len) < float(LenR)*1.05):
				tmp_clstr[0].append([Name, Len, pid])
			else:
				isnewClstr = True
				# check other entry
				for j in range(len(tmp_clstr) - 1):
					if (float(pid) >= float(tmp_clstr[j][0][2])*0.95 and float(pid) <= float(tmp_clstr[j][0][2])*1.05) and \
						(float(Len) >= float(tmp_clstr[j][0][1])*0.95 and float(Len) <= float(tmp_clstr[j][0][1])*1.05):
						tmp_clstr[j].append([Name, Len, pid])
						isnewClstr = False
						break
				# if no match create new cluster
				if isnewClstr == True:
					i = i + 1
					tmp_clstr[i] = [[Name, Len, pid]]	
		
		# discard singletons
		for newClstr in tmp_clstr:
			# remove outliers clusters
			# if len(tmp_clstr[newClstr]) < 311 or len(tmp_clstr[newClstr]) > 350:
			# 	# print to log
			#	for entry in tmp_clstr[newClstr]:
			#		filter_log.append([clstr, "subclstr " + str(newClstr), entry[0], entry[1], entry[2], "Discarded"])
			#else:
				# print to log
				clean_clstrDB.append(tmp_clstr[newClstr])
				for entry in tmp_clstr[newClstr]:					
					filter_log.append([clstr, "subclstr " + str(newClstr), entry[0], entry[1], entry[2], "Retained"])
	
	return(clean_clstrDB, filter_log)
	

	
def print_Log(filter_log):
	'''
	I print a summary of filtering clusters.
	'''
	
	# define outfile
	outLog = "all_plusKV.nt.098.fa.clstr.log"
	oF = open(outLog, 'w')
		
	# print header
	oF.write('# Original Cluster\tSubcluster\tGene\tLength\t%Id\tFiltered?\n')
	
	# print output
	for Entry in filter_log:
		oF.write('\t'.join(Entry) + '\n')
	
	oF.close()
	
	
	
def print_clstr(clean_clstrDB):
	'''
	I print a list of genes for each cluster.
	'''	
	
	# print the clusters
	i = 0
	for clstr in clean_clstrDB:
		# define outfile
		outClstr = "all_plusKV.nt.098.fa.clstr.fltr.clstr." + str(i)
		oF = open(outClstr, 'w')
		for k in range(len(clstr)):
			oF.write(clstr[k][0] + '\n')
		oF.close()	
		i = i + 1



def print_GeneMatrix(clean_clstrDB):
	'''
	I print a matrix with gene/species occupancy for each cluster that passed the filter.
	'''	
	
	# get Strain list
	StrainList = []
	for clstr in clean_clstrDB:
		for k in range(len(clstr)):
			Strain = clstr[k][0].split('_')[0]
			if re.match('WL1EUK', Strain):
				continue
			else:
				if Strain not in StrainList:
					StrainList.append(Strain)
	
	# create Matrix
	i = 0
	Matrix = []
	Matrix.append(['# Cluster', '\t'.join(StrainList)])
	for clstr in clean_clstrDB:
		NewRow = [0 for k in range(len(StrainList))]
		for k in range(len(StrainList)):
			for Gene in clstr:
				StrainG = Gene[0].split('_')[0]
				if re.match('WL1EUK', Strain):
					continue
				else:
					if StrainG == StrainList[k]:
						NewRow[k] = NewRow[k] + 1
		for k in range(len(NewRow)):
			NewRow[k] = str(NewRow[k])
		i = i + 1
		Matrix.append([str(i), '\t'.join(NewRow)])
	
	# print the Matrix
	outMatrix = "all_plusKV.nt.098.clstr.fltr.Matrix.txt"
	oF = open(outMatrix, 'w')
	for Entry in Matrix:
		oF.write('\t'.join(Entry) + '\n')
	oF.close()	



#------------------------------------------------------------------#
# RUN                                                            

# run script and give the running time
if __name__ == '__main__':
	t0 = datetime.now()
	main()
	dt = datetime.now() - t0
sys.stderr.write( "# Time elapsed: %s\n" % dt )
